package javasudoku.view;
import java.awt.Color;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.PlainDocument;
import javasudoku.model.SudokuCoordinate;

/**
 * A custom JPanel containing a text field enabling the input of numbers to simulate
 * a Sudoku cell value
 * @author Ishaiah Cross
 */
public class CellPanel extends javax.swing.JPanel {
    //Regular expression objects used to format cell input properly
    private SudokuCoordinate coordinate;
    private final Pattern inputTextFormatter;
    private Matcher inputTextMatcher;
    
    /**
     * Creates new form GUISudokuPanel
     */
    public CellPanel() {
        //Initialize regex
        inputTextFormatter = Pattern.compile("^[1-9]$");
        
        initComponents();
        initTextFormatHandler();
       
    }
    
    /**
     * Initializes the format handler for when text is entered
     */
    private void initTextFormatHandler() {
        cellValueText.setDocument(new CellFormatDocument());
        setFocusTraversalKeysEnabled(false); //Prevent tabbing across cells
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        cellValueText = new javax.swing.JTextField();

        setBackground(new java.awt.Color(255, 255, 255));
        setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(153, 153, 153)));
        setPreferredSize(new java.awt.Dimension(40, 40));

        cellValueText.setBackground(new java.awt.Color(204, 204, 204));
        cellValueText.setFont(new java.awt.Font("Verdana", 0, 24)); // NOI18N
        cellValueText.setForeground(new java.awt.Color(0, 0, 0));
        cellValueText.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        cellValueText.setText(".");
        cellValueText.setBorder(null);
        cellValueText.setFocusTraversalPolicyProvider(true);
        cellValueText.setMinimumSize(new java.awt.Dimension(40, 40));
        cellValueText.setPreferredSize(new java.awt.Dimension(40, 40));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(cellValueText, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(cellValueText, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField cellValueText;
    // End of variables declaration//GEN-END:variables
    
    /**
     * Changes the colour of the cell text to represent whether or not the
     * cell is in a valid state.
     * @param valid Whether or not the cell is valid. True for black, false for red.
     */
    public void setValid(boolean valid) {
        cellValueText.setForeground(valid ? Color.black : Color.red);
    }
    
    /**
     * Set the value displayed by the cell
     * @param value The value to be displayed
     */
    public void setValue(int value) {
        cellValueText.setText(value == 0 ? "" : Integer.toString(value));
    }
    
    /**
     * Returns the value displayed by the cell, or null if the cell has no text
     * @return The value displayed by the cell as an integer
     */
    public int getValue() {
        String text = cellValueText.getText();
        return Integer.parseInt(text);
    }
    
    /**
     * @return the coordinate
     */
    public SudokuCoordinate getCoordinate() {
        return coordinate;
    }

    /**
     * @param coordinate the coordinate to set
     */
    public void setCoordinate(SudokuCoordinate coordinate) {
        this.coordinate = coordinate;
    }
    
    /**
     * A Swing document subclass, overriding the insertString method
     * to ensure that only one numerical character
     * can be entered into the cell
     */
    private class CellFormatDocument extends PlainDocument {
        private static final int MAX_CHARS = 1;
        
        @Override
        public void insertString(int offs, String str, AttributeSet a) throws BadLocationException {
            if(!(str == null || str.isEmpty())) { //Only need to override behaviour if text was entered
                //Check the length of the new input, if it fits, call the superclass method to update the text field
                if(getLength() + str.length() <= MAX_CHARS) {
                    //Check that the input only contains numbers using regex
                    Matcher inputTextMatcher = inputTextFormatter.matcher(str);
                    
                    if(inputTextMatcher.find()) {
                        super.insertString(offs, str, a);
                    }
                }
            }
        }
    }
    
    /* Sets whether or not the text field within the cell can be edited
     * @param active Whether or not the text field can be edited (true for editable, false for not)
     */
    public void setActive(boolean active) {
        cellValueText.setEditable(active);
    }
}
