package javasudoku.model;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;
import javasudoku.solver.SudokuSolver;

/**
 * Generates partially solved Sudoku boards that have one unique solution.
 * Puzzles are generated by using the SudokuSolver to first generate a fully
 * solved Sudoku board, then removing cells.
 * 
 * @author Ishaiah Cross
 */
public class SudokuGenerator {
    private static final int MIN_DIFFICULTY = 5;
    private static final int MAX_DIFFICULTY = 75;
    
    private static final int MAX_REMOVE_ATTEMPTS = 20;
    
    private final SudokuSolver solver;
    private final ArrayList<Integer> subgridRandomizer;
    
    public SudokuGenerator() {
        this.solver = new SudokuSolver();
        this.subgridRandomizer = new ArrayList<>(); //Stores a configuration of subgrid values used in fillSubgrids
        
        for(int i = 0; i < SudokuBoard.CELL_MAX; i++)
            this.subgridRandomizer.add(i + 1);
    }
    
     /**
     * @return the SudokuSolver object the generator uses
     */
    public SudokuSolver getSolver() {
        return solver;
    }
    
    /**
     * Generates a random, fully solved sudoku board
     * @return A randomly solved SudokuBoard object
     */
    public SudokuBoard generateBoard() {
        SudokuBoard board = new SudokuBoard();
        fillSubgrids(board); //Randomize the subgrids
        solver.solveBoard(board); //Solve the board completely
        
        return board;
    }
    
    /**
     * Converts a difficulty value into a number of removal attempts for the
     * puzzle generation algorithm to use
     * @param difficulty The desired difficulty, clamped between
     * MIN_DIFFICULTY and MAX_DIFFICULTY
     * @return The number of removal attempts to make
     */
    private int getNumRemovalAttempts(int difficulty) {
        //Clamp the value between MIN_DIFFICULTY and MAX_DIFFICULTY
        if(difficulty < MIN_DIFFICULTY)
            difficulty = MIN_DIFFICULTY;
        
        if(difficulty > MAX_DIFFICULTY)
            difficulty = MAX_DIFFICULTY;
        
        return difficulty;
    }
    
    /**
     * Generates a partially solved Sudoku puzzle with one unique solution.
     * 
     * @param difficulty The desired difficulty, clamped between
     * MIN_DIFFICULTY and MAX_DIFFICULTY
     * @return A partially solved Sudoku board with one unique solution
     */
    public SudokuBoard generatePuzzle(int difficulty) {
        //Generate a solved board
        SudokuBoard puzzle = generateBoard(); 
        //Determine how many times to attempt to remove a cell
        int numRemovalAttempts = getNumRemovalAttempts(difficulty); 
        //Remove cells from the board to create the puzzle
        removeCells(puzzle, numRemovalAttempts); 
        
        return puzzle;
    }
    
    /**
     * Fills the diagonal subgrids of a Sudoku board with random values 1-9.
     * 
     * Subgrids along a single diagonal can always be initialized with random values 1-9 with no conflict.
       Doing this greatly reduces the number of cells that the solver algorithm has to check and thus saves processing time.
       * 
     * @param board The board to fill the diagonal subgrids of
     */
    private void fillSubgrids(SudokuBoard board) {
        SudokuCoordinate curPosition = new SudokuCoordinate(0, 0);
        
        for(int subgridIndex = 0; subgridIndex < SudokuBoard.SUBGRID_COUNT; subgridIndex++) {
            /*Since diagonal subgrids lie along the line y=x, this formula 
            gives the x and y coordinate of the top-left cell of each diagonal subgrid from top-left to bottom-right*/
            int subgridCoordinate = subgridIndex * SudokuBoard.SUBGRID_SIZE;
            
            //Shuffle the arraylist of values to be inserted into this subgrid, and re-initialize the index
            Collections.shuffle(subgridRandomizer);
            int randIndex = 0;
            
            //Perform a double nested loop to iterate over the subgrid starting from the top-left coordinate
            for(int offsY = 0; offsY < SudokuBoard.SUBGRID_SIZE; offsY++) {
                for(int offsX = 0; offsX < SudokuBoard.SUBGRID_SIZE; offsX++) {
                    //Get the current position of the cell in the space of the entire board
                    curPosition.setY(subgridCoordinate + offsY);
                    curPosition.setX(subgridCoordinate + offsX);
                
                    /*Fill the subgrid cells with subsequent unique values from the shuffled arraylist.
                    We can set the value directly using setCellValue without checking for clashes first because
                    we already know diagonal subgrids do not intersect with each other, and all the values
                    going into this subgrid are unique.*/
                    SudokuCell cell = board.getCell(curPosition);
                    cell.setCellValue(subgridRandomizer.get(randIndex));
                    
                    //Move to the next value from the arraylist
                    randIndex++;
                }
            }
        }
    }
    
    /**
     * Removes n cells from the given solved board. This will ensure that the board
     * still has one unique solution. 
     * 
     * This function will stop removing cells if a unique solution can no longer be reached following
     * the removal of any cell.
     * 
     * This function will modify the board that is passed in.
     * 
     * @param board The board to remove cells from
     * @param n The number of removal attempts to make
     */
    private void removeCells(SudokuBoard board, int n) {
        SudokuCoordinate curPosition = new SudokuCoordinate(0,0);
        Random rand = new Random();
        int totalAttempts = 0;

        //Iterate n times to remove n cells
        for(int i = 0; i < n; i++) {
            int randX = rand.nextInt(SudokuBoard.GRID_SIZE);
            int randY = rand.nextInt(SudokuBoard.GRID_SIZE);
            
            curPosition.setX(randX);
            curPosition.setY(randY);
            
            //Store the value at this cell so it can be replaced if necessary
            int cellValue = board.getCellValue(curPosition);
            
            //Remove this cell and check if there are now multiple solutions
            board.setCell(curPosition, 0);
            if(!solver.hasUniqueSolution(board)) {
                //Restore the cell and try again. Set directly so that we do not have to check if the placement is valid
                SudokuCell cellAt = board.getCell(curPosition);
                cellAt.setCellValue(cellValue);
                //Decrement i so that one more attempt is made to compensate
                i--;
                //Increment the total number of failed attempts. If we failed too many times, exit the function
                if(totalAttempts++ > MAX_REMOVE_ATTEMPTS)
                    return;
            }
        } 
    }
}

