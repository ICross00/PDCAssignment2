package javasudoku.solver;
import java.util.ArrayList;
import java.util.Collections;
import javasudoku.model.SudokuBoard;
import javasudoku.model.SudokuCell;
import javasudoku.model.SudokuCoordinate;

/**
 * Implements a backtracking algorithm to solve Sudoku puzzles. By default,
 * Solutions are searched for using the lowest possible value that
 * can be inserted into each cell from top-left to bottom-right.
 * 
 * Random solutions can be generated by calling the randomizeSearchOrder
 * function before calling the solve function. 
 * 
 * @author Ishaiah Cross
 */
public class SudokuSolver {
    
    private final ArrayList<Integer> searchOrder;
    private boolean solved = false;
    
    public SudokuSolver() {
        this.solved = false;
        this.searchOrder = new ArrayList<>();
 
        for(int i = 0; i < SudokuBoard.CELL_MAX; i++) {
            this.searchOrder.add(i);
        }
    }
    
    /**
     * Randomizes the order in which cell values are tested. This ensures a random
     * solution is generated in the solveBoard function.
     */
    public void randomizeSearchOrder() {
        Collections.shuffle(this.searchOrder);
    }
    
    /**
     * Resets the order in which cell values are tested. This ensures the first
     * solution (lowest numbers attempted first) is generated in the solveBoard function.
     */
    public void resetSearchOrder() {
        Collections.sort(this.searchOrder);
    }
    
    
    /**
     * Uses a recursive backtracking algorithm to check if a Sudoku board 
     * has a unique solution.
     * 
     * @param board The board to check for a unique solution
     * @return True if the board has a unique solution, otherwise false
     */
    public boolean hasUniqueSolution(SudokuBoard board) {
        SolutionCounter count = new SolutionCounter();
        hasUniqueSolutionRecursive(board, count);
        
        return count.getNumSolutions() < 2;
    }
    
    /**
     * A recursive method that determines if a Sudoku board has one unique solution.
     * 
     * This method should not be used to solve a board as it only checks if there is 
     * more than one possible configuration that retains the solved state of the board.
     * 
     * This function is wrapped by hasUniqueSolution which creates a SolutionCount instance for the algorithm to use.
     * 
     * @param board The board to check for a unique solution
     * @param count A SolutionCount object to keep track of the number of solutions found
     */
    private void hasUniqueSolutionRecursive(SudokuBoard board, SolutionCounter count) {
        //Find the first empty cell that can be tested for multiple solutions
        SudokuCell cellCandidate = board.getEmptyCell();
        //If there were no empty cells, we reached a solution, so increment the counter
        if(cellCandidate == null) {
            count.addSolution();
            return;
        }
        
        SudokuCoordinate cellPosition = cellCandidate.getPosition();
        //curPosition now contains the first empty cell, check that it only has one possibilty
        for(int n: searchOrder) {
            //Attempt to put each number in this cell
            if(board.setCell(cellPosition, n + 1)) {
                //If we succeeded, count the number of solutions again using this configuration
                hasUniqueSolutionRecursive(board, count);
                //Unassign the cell so that we can backtrack other possible solutions
                board.setCell(cellPosition, 0);
            }
            
            //Stop testing possibilities if more than one solution was found.
            if(count.getNumSolutions() > 1)
                return;
        }
    }
    
    /**
     * Uses a recursive backtracking algorithm to solve a Sudoku board.
     * @param board The board to solve
     */
    public void solveBoard(SudokuBoard board) {
        SolvedStatus status = new SolvedStatus();
        solveBoardRecursive(board, status);
    }
    
    /**
     * Implementation of the recursive backtracking algorithm to solve Sudoku boards.
     * The algorithm has been modified to support searching for solutions in either random or lowest-first order via the
     * randomizeSearchOrder and resetSearchOrder functions.
     * 
     * This function will modify the board that is passed in.
     * 
     * This function is wrapped by solveBoard which creates a SolvedStatus object for the algorithm to use.
     * 
     * @param board The board to solve
     * @param status A SolvedStatus instance for the algorithm to keep track of whether or not a solution has been reached.
     */
    private void solveBoardRecursive(SudokuBoard board, SolvedStatus status) {
        SudokuCoordinate curPosition = new SudokuCoordinate(0,0);

        //Iterate over every cell in the board     
        for(int y = 0; y < SudokuBoard.GRID_SIZE; y++) {
            for(int x = 0; x < SudokuBoard.GRID_SIZE; x++) {
                //Update our current position
                curPosition.setX(x);
                curPosition.setY(y);
                
                //If the cell was empty (i.e. value of 0) attempt to put all possible values there
                int cellValue = board.getCellValue(curPosition);
                if(cellValue == 0) {
                    //Try to put each value from 1-9 in this cell, and go with the first successful one. Backtrack later if it lead to a dead end.
                    for(int n: searchOrder) {
                        if(board.setCell(curPosition, n + 1)) {
                            //Run the algorithm again on the updated board to solve for the next cell
                            solveBoardRecursive(board, status);
                            
                            //If this call solved the board, we no longer need to keep checking so we return
                            if(status.hasSolved)
                                return;
                            
                            //When this point is reached and the board is not solved, something further up the stack determined we could not solve using this path, so we need to reset
                            //the cell and backtrack
                            board.setCell(curPosition, 0);
                        }   
                    }
                    
                    //If we have tried all numbers 1-9 without success, we need to return i.e. go back up the stack and try again
                    return;
                }
            } 
        }
        
        //If we have reached this line, the entire grid has been filled, and a solution is found
        status.hasSolved = true;
    }
}
